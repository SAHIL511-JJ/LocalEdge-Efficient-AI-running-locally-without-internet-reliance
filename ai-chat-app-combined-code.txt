# AI Chat App - Combined Code

## package.json
```json
{
  "name": "ai-chat-app",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "eslint"
  },
  "dependencies": {
    "@auth/supabase-adapter": "^1.11.1",
    "@prisma/client": "^6.19.0",
    "@supabase/supabase-js": "^2.81.1",
    "axios": "^1.13.2",
    "bcrypt": "^6.0.0",
    "clsx": "^2.1.1",
    "formidable": "^3.5.4",
    "framer-motion": "^12.23.24",
    "next": "16.0.3",
    "next-auth": "^4.24.13",
    "prisma": "^6.19.0",
    "react": "19.2.0",
    "react-dom": "19.2.0",
    "react-markdown": "^10.1.0",
    "react-syntax-highlighter": "^16.1.0",
    "zod": "^4.1.12",
    "zustand": "^5.0.8"
  },
  "devDependencies": {
    "@tailwindcss/postcss": "^4",
    "@types/node": "^20",
    "@types/react": "^19",
    "@types/react-dom": "^19",
    "autoprefixer": "^10.4.22",
    "babel-plugin-react-compiler": "1.0.0",
    "eslint": "^9",
    "eslint-config-next": "16.0.3",
    "postcss": "^8.5.6",
    "tailwindcss": "^3.4.10",
    "typescript": "^5"
  }
}
```

## tsconfig.json
```json
{
  "compilerOptions": {
    "target": "ES2017",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "react-jsx",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./*"]
    }
  },
  "include": [
    "next-env.d.ts",
    "**/*.ts",
    "**/*.tsx",
    ".next/types/**/*.ts",
    ".next/dev/types/**/*.ts",
    "**/*.mts"
  ],
  "exclude": ["node_modules"]
}
```

## next.config.ts
```ts
import type { NextConfig } from "next";

const nextConfig: NextConfig = {
  /* config options here */
  reactCompiler: true,
};

export default nextConfig;
```

## tailwind.config.js
```js
/** @type {import('tailwindcss').Config} */
module.exports = {
  darkMode: ["class"],
  content: [
    "./app/**/*.{js,ts,jsx,tsx}",
    "./components/**/*.{js,ts,jsx,tsx}",
  ],
  theme: {
    extend: {
      colors: {
        primary: {
          50: "#f5f3fb",
          100: "#e9e3f7",
          500: "#7c5cff", // premium light purple
        },
      },
      backdropBlur: {
        xs: "4px",
        sm: "6px",
        md: "12px",
      },
      borderRadius: {
        xl: "1rem",
        "2xl": "1.25rem",
      },
      boxShadow: {
        glass: "0 8px 30px rgba(45, 30, 80, 0.12)", // soft premium shadow
      },
    },
  },
  plugins: [],
};
```

## postcss.config.mjs
```js
const config = {
  plugins: {
    "@tailwindcss/postcss": {},
  },
};

export default config;
```

## eslint.config.mjs
```js
import { defineConfig, globalIgnores } from "eslint/config";
import nextVitals from "eslint-config-next/core-web-vitals";
import nextTs from "eslint-config-next/typescript";

const eslintConfig = defineConfig([
  ...nextVitals,
  ...nextTs,
  // Override default ignores of eslint-config-next.
  globalIgnores([
    // Default ignores of eslint-config-next:
    ".next/**",
    "out/**",
    "build/**",
    "next-env.d.ts",
  ]),
]);

export default eslintConfig;
```

## postcss.config.js
```js
module.exports = {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}
```

## .gitignore
```
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.*
.yarn/*
!.yarn/patches
!.yarn/plugins
!.yarn/releases
!.yarn/versions

# testing
/coverage

# next.js
/.next/
/out/

# production
/build

# misc
.DS_Store
*.pem

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*
.pnpm-debug.log*

# env files (can opt-in for committing if needed)
.env*

# vercel
.vercel

# typescript
*.tsbuildinfo
next-env.d.ts
```

## README.md
```
This is a [Next.js](https://nextjs.org) project bootstrapped with [`create-next-app`](https://nextjs.org/docs/app/api-reference/cli/create-next-app).

## Getting Started

First, run the development server:

```bash
npm run dev
# or
yarn dev
# or
pnpm dev
# or
bun dev
```

Open [http://localhost:3000](http://localhost:3000) with your browser to see the result.

You can start editing the page by modifying `app/page.tsx`. The page auto-updates as you edit the file.

This project uses [`next/font`](https://nextjs.org/docs/app/building-your-application/optimizing/fonts) to automatically optimize and load [Geist](https://vercel.com/font), a new font family for Vercel.

## Learn More

To learn more about Next.js, take a look at the following resources:

- [Next.js Documentation](https://nextjs.org/docs) - learn about Next.js features and API.
- [Learn Next.js](https://nextjs.org/learn) - an interactive Next.js tutorial.

You can check out [the Next.js GitHub repository](https://github.com/vercel/next.js) - your feedback and contributions are welcome!

## Deploy on Vercel

The easiest way to deploy your Next.js app is to use the [Vercel Platform](https://vercel.com/new?utm_medium=default-template&filter=next.js&utm_source=create-next-app&utm_campaign=create-next-app-readme) from the creators of Next.js.

Check out our [Next.js deployment documentation](https://nextjs.org/docs/app/building-your-application/deploying) for more details.
```

## app/globals.css
```css
@tailwind base;
@tailwind components;
@tailwind utilities;

/* Global Reset */
html, body {
  height: 100%;
  margin: 0;
  padding: 0;
}

/* Smooth edges & anti-alias */
* {
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  -webkit-tap-highlight-color: transparent;
}

/* Background theme */
body {
  background: linear-gradient(
    180deg,
    rgba(240, 236, 255, 0.4),
    rgba(244, 240, 255, 0.6)
  );
}

/* Scrollbar styling (premium look) */
::-webkit-scrollbar {
  width: 6px;
}

::-webkit-scrollbar-thumb {
  background: rgba(130, 100, 255, 0.4);
  border-radius: 9999px;
}

::-webkit-scrollbar-track {
  background: transparent;
}
```

## app/layout.tsx
```tsx
import "./globals.css";
import "../styles/theme.css";
import { Inter } from "next/font/google";

const inter = Inter({ subsets: ["latin"] });

export const metadata = {
  title: "AI Chat App",
  description: "Premium Glassy Next.js Chat App using DeepSeek",
};

export default function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <html lang="en">
      <body className={`${inter.className} min-h-screen`}>
        {children}
      </body>
    </html>
  );
}
```

## app/page.tsx
```tsx
import Link from "next/link";

export default function HomePage() {
  return (
    <div className="flex items-center justify-center h-screen">
      <div className="glass-card max-w-lg w-full text-center">
        <h1 className="text-3xl font-semibold mb-4 text-primary-500">
          Premium AI Chat App
        </h1>
        <p className="text-gray-700 mb-6">
          A modern, glass-themed AI chat interface powered by DeepSeek.
        </p>

        <Link
          href="/chat"
          className="px-6 py-3 bg-primary-500 text-white rounded-xl shadow-lg"
        >
          Open Chat
        </Link>
      </div>
    </div>
  );
}
```

## lib/gemini.ts
```ts
// lib/gemini.ts

export type Message = {
  role: "user" | "model";
  content: string;
};

export async function sendMessagesStream(messages: Message[]) {
  const apiKey = process.env.GEMINI_API_KEY!;
  const model = process.env.GEMINI_MODEL ?? "gemini-2.5-flash";

  const response = await fetch(
    `https://generativelanguage.googleapis.com/v1beta/models/${model}:streamGenerateContent?key=${apiKey}`,
    {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Accept": "text/event-stream", // ⭐ REQUIRED FOR SSE
      },
      body: JSON.stringify({
        contents: messages.map((m) => ({
          role: m.role,
          parts: [{ text: m.content }],
        })),
        generationConfig: {
          temperature: 0.7,
        },
      }),
    }
  );

  if (!response.ok) {
    const error = await response.text();
    throw new Error("Gemini API Error: + error);
  }

  return response; // SSE BODY — do not parse here!
}
```

## lib/huggingface.ts
```ts
// lib/huggingface.ts

export type Message = {
  role: "user" | "assistant";
  content: string;
};

export async function sendMessagesStream(messages: Message[]) {
  const HF_TOKEN = process.env.HF_TOKEN!;
  const MODEL = process.env.HF_MODEL || "google/gemma-2b-it";

  // Determine if this is a chat model based on the model name
  const isChatModel = MODEL.includes('chat') || MODEL.includes('instruct') || MODEL.includes('gemma') || MODEL.includes('llama') || MODEL.includes('mistral');

  let payload: any;

  if (isChatModel) {
    // For chat models, use the messages format
    payload = {
      messages: messages.map(msg => ({
        role: msg.role,
        content: msg.content
      })),
      options: {
        wait_for_model: true
      },
      parameters: {
        max_new_tokens: 200,
        temperature: 0.7,
        top_p: 0.9,
      }
    };
  } else {
    // For text generation models, use the inputs format
    const inputs = formatConversationForHuggingFace(messages);
    payload = {
      inputs: inputs,
      options: {
        wait_for_model: true
      },
      parameters: {
        max_new_tokens: 100,
        temperature: 0.7,
        top_p: 0.9,
        return_full_text: false,
      }
    };
  }

  // Use the standard Hugging Face Inference API endpoint
  const response = await fetch(
    `https://api-inference.huggingface.co/models/${MODEL}`,
    {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Authorization": `Bearer ${HF_TOKEN}`,
      },
      body: JSON.stringify(payload),
    }
  );

  if (!response.ok) {
    const error = await response.text();
    console.error("Hugging Face API Error:", error);
    throw new Error("Hugging Face API Error: " + error);
  }

  // Return the response for the route to handle
  return response;
}

function formatConversationForHuggingFace(messages: Message[]): string {
  return messages.map(msg => {
    if (msg.role === "user") {
      return `User: ${msg.content}`;
    } else {
      return `Assistant: ${msg.content}`;
    }
  }).join('\n\n');
}
```

## lib/prisma.ts
```ts
// lib/prisma.ts
import { PrismaClient } from "@prisma/client";

declare global {
  var prisma: PrismaClient | undefined;
}

const prisma = global.prisma || new PrismaClient();

if (process.env.NODE_ENV !== "production") global.prisma = prisma;

export default prisma;
```

## prisma/schema.prisma
```
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id            String          @id @default(uuid())
  email         String          @unique
  password      String
  name          String?
  image         String?
  createdAt     DateTime        @default(now())

  conversations Conversation[]
  messages      Message[]
}

model Conversation {
  id        String     @id @default(uuid())
  title     String
  createdAt DateTime   @default(now())
  updatedAt DateTime   @updatedAt

  userId    String
  user      User       @relation(fields: [userId], references: [id])

  messages  Message[]
}

model Message {
  id             String       @id @default(uuid())
  role           String
  content        String
  createdAt      DateTime     @default(now())

  conversationId String
  conversation   Conversation @relation(fields: [conversationId], references: [id])

  userId         String?
  user           User?        @relation(fields: [userId], references: [id])
}
```

## styles/theme.css
```css
:root {
  --glass-bg: rgba(255, 255, 255, 0.08);
  --glass-border: rgba(255, 255, 255, 0.15);
  --glass-shadow: rgba(80, 60, 150, 0.25);
  --accent-light: #f5f3fb;
  --accent-purple: #7c5cff;
  --accent-purple-light: #e9e3f7;

.glass-card {
  backdrop-filter: blur(12px);
  background: var(--glass-bg);
  border: 1px solid var(--glass-border);
  box-shadow: 0 8px 30px var(--glass-shadow);
  border-radius: 1.25rem;
  padding: 1rem;
}
```

## components/Loader.tsx
```tsx
export default function Loader() {
  return (
    <div className="animate-pulse text-primary-500 font-semibold">
      Loading...
    </div>
  );
}
```

## components/ThemeProvider.tsx
```tsx
export default function ThemeProvider({ children }: { children: React.ReactNode }) {
  return <>{children}</>;
}
```

## components/ui/Button.tsx
```tsx
export default function Button({
  children,
  className = "",
  ...props
}: any) {
  return (
    <button
      className={`px-4 py-2 bg-primary-500 text-white rounded-xl shadow ${className}`}
      {...props}
    >
      {children}
    </button>
  );
}
```

## components/ui/GlassCard.tsx
```tsx
export default function GlassCard({
  children,
  className?: string;
}) {
  return (
    <div className={`glass-card ${className}`}>
      {children}
    </div>
  );
}
```

## app/chat/components/ChatInput.tsx
```tsx
"use client";

import { useState } from "react";

export default function ChatInput({ conversationId }: { conversationId?: string }) {
  const [value, setValue] = useState("");
  const [streaming, setStreaming] = useState(false);

  async function sendMessage() {
    if (!value.trim") return;

    const text = value;
    setValue("");

    window.dispatchEvent(
      new CustomEvent("chat:message", {
        detail: { role: "user", content: text },
      })
    );

    setStreaming(true);

    const res = await fetch("/api/chat/send", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ message: text, conversationId }),
    });

    if (!res.body) {
      setStreaming(false;
      return;
    }

    const reader = res.body.getReader();
    const decoder = new TextDecoder();

    while (true) {
      const { value: chunk, done } = await reader.read();
      if (done) break;

      const text = decoder.decode(chunk);

      window.dispatchEvent(
        new CustomEvent("chat:stream", {
          detail: { chunk: text },
        })
      );
    }

    window.dispatchEvent(new CustomEvent("chat:stream:end"));
    setStreaming(false);
  }

  return (
    <div className="flex items-center gap-3 p-4">
      <input
        className="flex-1 p-3 rounded-xl border bg-white/70"
        placeholder="Type a message..."
        value={value}
        onChange={(e) => setValue(e.target.value)}
        onKeyDown={(e) => {
          if (e.key === "Enter") sendMessage();
        }}
      />

      <button
        onClick={sendMessage}
        disabled={streaming}
        className="px-5 py-3 bg-primary-500 text-white rounded-xl"
      >
        {streaming ? "..." : "Send"}
      </button>
    </div>
  );
}
```

## app/chat/components/ChatMessage.tsx
```tsx
export default function ChatMessage({
  message,
  role,
}: {
  message: string;
  role: "user" | "assistant";
}) {
  return (
    <div
      className={`p-3 rounded-xl max-w-xl ${
        role === "assistant"
          ? "glass-card"
          : "bg-primary-500 text-white ml-auto"
      }`}
    >
      {message}
    </div>
  );
}
```

## app/chat/components/ChatWindow.tsx
```tsx
"use client";

import { useEffect, useRef, useState } from "react";

type Msg = {
  id: string;
  role: "user" | "assistant";
  content: string;
};

export default function ChatWindow() {
  const [messages, setMessages] = useState<Msg[]>([
    {
      id: "welcome",
      role: "assistant",
      content: "Hello! Ask me anything.",
    },
  ]);

  const bottomRef = useRef<HTMLDivElement | null>(null);

  useEffect(() => {
    function scroll() {
      bottomRef.current?.scrollIntoView({ behavior: "smooth" });
    }
    scroll();
  }, [messages]);

  useEffect(() => {
    function onUser(e: any) {
      const { role, content } = e.detail;

      setMessages((prev) => [
        ...prev,
        { id: String(Date.now()), role, content },
      ]);
    }

    function onStream(e: any) {
      const chunk = e.detail.chunk as string;

      setMessages((prev) => {
        const last = prev[prev.length - 1];

        if (!last || last.role !== "assistant") {
          return [
            ...prev,
            {
              id: String(Date.now()),
              role: "assistant",
              content: chunk,
            },
          ];
        } else {
          return prev.slice(0, -1).concat([
            { ...last, content: last.content + chunk },
          ]);
        }
      });
    }

    function onStreamEnd() {}

    window.addEventListener("chat:message", onUser);
    window.addEventListener("chat:stream", onStream);
    window.addEventListener("chat:stream:end", onStreamEnd);

    return () => {
      window.removeEventListener("chat:message", onUser);
      window.removeEventListener("chat:stream", onStream);
      window.removeEventListener("chat:stream:end", onStreamEnd);
    };
  }, []);

  return (
    <div className="flex-1 overflow-y-auto p-6 space-y-4">
      {messages.map((m) => (
        <div
          key={m.id}
          className={`max-w-xl p-4 rounded-2xl shadow-sm ${
            m.role === "assistant"
              ? "glass-card text-black"
              : "bg-primary-500 text-white ml-auto"
          }`}
        >
          {m.content}
        </div>
      ))}

      <div ref={bottomRef} />
    </div>
  );
}
```

## app/chat/components/FileUploader.tsx
```tsx
export default function FileUploader() {
  return (
    <div className="glass-card p-3 text-center text-sm text-gray-600">
      File Upload UI Coming Soon
    </div>
  );
}
```

## app/chat/components/Sidebar.tsx
```tsx
"use client";

import { useEffect, useState } from "react";
import Link from "next/link";

export default function Sidebar() {
  const [conversations, setConversations] = useState<any[]>([]);

  async function load() {
    const res = await fetch("/api/chat/search");
    const data = await res.json();
    setConversations(data.conversations || []);
  }

  async function newChat() {
    const res = await fetch("/api/chat/new", { method: "POST" });
    const data = await res.json();
    window.location.href = `/chat/${data.id}`;
  }

  useEffect(() => {
    load();
  }, []);

  return (
    <div className="w-64 bg-white/40 backdrop-blur-xl p-4 border-r h-screen">
      <button
        onClick={newChat}
        className="w-full p-3 mb-4 bg-primary-500 text-white rounded-xl"
      >
        + New Chat
      </button>

      <div className="space-y-2">
        {conversations.length === 0 && (
          <p className="text-sm text-gray-500">No conversations yet...</p>
        )}

        {conversations.map((c) => (
          <Link
            key={c.id}
            href={`/chat/${c.id}`}
            className="block p-3 bg-white/70 rounded-xl shadow-sm hover:bg-white"
          >
            {c.title || "Untitled Chat"}
          </Link>
        ))}
      </div>
    </div>
  );
}
```

## app/chat/layout.tsx
```tsx
import Sidebar from "./components/Sidebar"; // adjust path if needed

export default function ChatLayout({ children }: { children: React.ReactNode }) {
  return (
    <div className="flex h-screen">
      {/* Sidebar */}
      <div className="w-[260px] border-r border-white/10 bg-white/5 backdrop-blur-xl">
        <Sidebar />
      </div>

      {/* Main content */}
      <div className="flex-1 overflow-hidden">
        {children}
      </div>
    </div>
  );
}
```

## app/chat/page.tsx
```tsx
import Sidebar from "./components/Sidebar";

export default function ChatHome() {
  return (
    <div className="flex h-screen">
      <Sidebar />
      <div className="flex items-center justify-center flex-1 glass-card text-center">
        <div>
          <h1 className="text-2xl font-semibold">Start a New Chat</h1>
          <p className="text-gray-600 mt-2">
            Select a conversation or create a new one.
          </p>
        </div>
      </div>
    </div>
  );
}
```

## app/chat/[id]/page.tsx
```tsx
import ChatWindow from "../components/ChatWindow";
import ChatInput from "../components/ChatInput";

export default async function ChatPage({ params }: any) {
  const { id } = await params;

  return (
    <div className="flex flex-col h-full">
      <ChatWindow conversationId={id} />
      <ChatInput conversationId={id} />
    </div>
  );
}
```

## app/api/test/route.ts
```ts
import { NextResponse } from "next/server";

export async function GET() {
  return NextResponse.json({
    GEMINI_KEY_EXISTS: !!process.env.GEMINI_API_KEY,
    GEMINI_KEY_VALUE: process.env.GEMINI_API_KEY?.slice(0, 8) + "...",
    LOADED_MODEL: process.env.GEMINI_MODEL
  });
}
```

## app/api/test-gemini/route.ts
```ts
import { NextResponse } from "next/server";

export async function GET() {
  try {
    const res = await fetch(
      "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:streamGenerateContent?key=" + process.env.GEMINI_API_KEY,
      {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          contents: [
            {
              role: "user",
              parts: [{ text: "Hello, respond with only: OK" }],
            },
          ],
        }),
      }
    );

    const reader = res.body.getReader();
    const decoder = new TextDecoder();

    let full = "";

    while (true) {
      const { done, value } = await reader.read();
      if (done) break;

      const chunk = decoder.decode(value);
      full += chunk;
    }

    return NextResponse.json({ success: true, raw: full });
  } catch (err) {
    return NextResponse.json({ error: String(err) });
  }
}
```

## app/api/auth/[...nextauth]/route.ts
```ts
// app/api/auth/[...nextauth]/route.ts
import NextAuth from "next-auth";
import CredentialsProvider from "next-auth/providers/credentials";
import { PrismaClient } from "@prisma/client";
import bcrypt from "bcrypt";

const prisma = new PrismaClient();

export const authOptions = {
  providers: [
    CredentialsProvider({
      name: "credentials",
      credentials: { email: {}, password: {} },

      async authorize(credentials: any) {
        const user = await prisma.user.findUnique({
          where: { email: credentials.email },
        });

        if (!user) return null;

        const valid = await bcrypt.compare(credentials.password, user.password);
        if (!valid) return null;

        return {
          id: user.id,
          email: user.email,
          name: user.name,
        };
      },
    }),
  ],

  session: { strategy: "jwt" },
  secret: process.env.NEXTAUTH_SECRET,
};

const handler = NextAuth(authOptions);

export { handler as GET, handler as POST };
```

## app/api/auth/signup/route.ts
```ts
// app/api/auth/signup/route.ts
import { NextResponse } from "next/server";
import prisma from "@/lib/prisma";
import bcrypt from "bcrypt";

export async function POST(req: Request) {
  try {
    const { email, password, name } = await req.json();

    if (!email || !password) {
      return NextResponse.json({ error: "Missing fields" }, { status: 400 });
    }

    const exists = await prisma.user.findUnique({ where: { email } });
    if (exists) {
      return NextResponse.json({ error: "User already exists" }, { status: 400 });
    }

    const hashed = await bcrypt.hash(password, 10);

    const user = await prisma.user.create({
      data: { email, password: hashed, name },
    });

    return NextResponse.json({ success: true, user });
  } catch {
    return NextResponse.json({ error: "Server error" }, { status: 500 });
  }
}
```

## app/api/chat/new/route.ts
```ts
// app/api/chat/new/route.ts
import prisma from "@/lib/prisma";
import { NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "../../auth/[...nextauth]/route";

export async function POST() {
  const session = await getServerSession(authOptions);
  if (!session) return NextResponse.json({ error: "Not authenticated" }, { status: 401 });

  const user = await prisma.user.findUnique({
    where: { email: session.user!.email! },
  });

  const conv = await prisma.conversation.create({
    data: {
      title: "New Conversation",
      userId: user!.id,
    },
  });

  return NextResponse.json({ id: conv.id });
}
```

## app/api/chat/regenerate/route.ts
```ts
// app/api/chat/regenerate/route.ts
import prisma from "@/lib/prisma";
import { NextResponse } from "next/server";
import { sendMessagesStream } from "@/lib/huggingface";

export async function POST(req: Request) {
  const { conversationId } = await req.json();

  const history = await prisma.message.findMany({
    where: { conversationId },
    orderBy: { createdAt: "asc" },
  });

  const messages = history.map((m) => ({
    role: m.role === "assistant" ? "assistant" : "user",
    content: m.content,
  }));

  const response = await sendMessagesStream(messages);

  if (!response.ok) {
    const errorText = await response.text();
    console.error("Hugging Face API Error:", errorText);
    return NextResponse.json({ error: `Hugging Face API Error: ${errorText}` }, { status: 500 });
  }

  // Hugging Face returns JSON response (not a stream like Gemini)
  const result = await response.json();

  let assistantText = "";

  // Extract text depending on model response format
  if (Array.isArray(result)) {
    // For some models that return an array
    if (result[0] && result[0].generated_text) {
      assistantText = result[0].generated_text;
    } else if (result[0] && result[0].response) {
      assistantText = result[0].response;
    } else {
      // Fallback - just use the first element as text
      assistantText = JSON.stringify(result[0]);
    }
  } else if (result && result.generated_text) {
    // For text generation models
    assistantText = result.generated_text;
  } else if (result && result.choices && result.choices[0]) {
    // For chat-like models
    assistantText = result.choices[0].message?.content ||
                   result.choices[0].text ||
                   JSON.stringify(result);
  } else {
    // Fallback to stringifying the entire result
    assistantText = typeof result === 'string' ? result : JSON.stringify(result);
  }

  // Save assistant message to DB
  await prisma.message.create({
    data: {
      role: "assistant",
      content: assistantText,
      conversationId,
    },
  });

  // Create a stream to send the response back
  const encoder = new TextEncoder();

  const stream = new ReadableStream({
    start(controller) {
      // Send the complete response
      controller.enqueue(encoder.encode(assistantText));
      controller.close();
    }
  });

  return new Response(stream, {
    headers: {
      "Content-Type": "text/plain; charset=utf-8",
      "Cache-Control": "no-cache",
    },
  });
}
```

## app/api/chat/search/route.ts
```ts
export async function GET() {
  return Response.json({ message: "search coming soon" });
}
```

## app/api/chat/send/route.ts
```ts
// app/api/chat/send/route.ts

import { NextResponse } from "next/server";
import prisma from "@/lib/prisma";
import { authOptions } from "../../auth/[...nextauth]/route";
import { getServerSession } from "next-auth";
import { sendMessagesStream } from "@/lib/huggingface";

export async function POST(req: Request) {
  const session = await getServerSession(authOptions);
  if (!session) {
    return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
  }

  try {
    const { conversationId, message } = await req.json();

    if (!message) {
      return NextResponse.json({ error: "Message required" }, { status: 400 });
    }

    // Fetch user
    const user = await prisma.user.findUnique({
      where: { email: session.user!.email! },
    });

    let convId = conversationId;

    // Create conversation if needed
    if (!convId) {
      const newConv = await prisma.conversation.create({
        data: {
          title: message.slice(0, 40),
          userId: user!.id,
        },
      });
      convId = newConv.id;
    }

    // Save user message
    await prisma.message.create({
      data: {
        role: "user",
        content: message,
        userId: user!.id,
        conversationId: convId,
      },
    });

    // Fetch history
    const history = await prisma.message.findMany({
      where: { conversationId: convId },
      orderBy: { createdAt: "asc" },
      take: 30,
    });

    // Convert to Hugging Face role format (user/assistant)
    const messages = history.map((m) => ({
      role: m.role === "assistant" ? "assistant" : "user",
      content: m.content,
    }));

    // Call Hugging Face
    const response = await sendMessagesStream(messages);

    if (!response.ok) {
      const errorText = await response.text();
      console.error("Hugging Face API Error:", errorText);
      return NextResponse.json({ error: `Hugging Face API Error: ${errorText}` }, { status: 500 });
    }

    // Hugging Face returns JSON response (not a stream like Gemini)
    const result = await response.json();

    let assistantText = "";

    // Extract text depending on model response format
    if (Array.isArray(result)) {
      // For some models that return an array
      if (result[0] && result[0].generated_text) {
        assistantText = result[0].generated_text;
      } else if (result[0] && result[0].response) {
        assistantText = result[0].response;
      } else {
        // Fallback - just use the first element as text
        assistantText = JSON.stringify(result[0]);
      }
    } else if (result && result.generated_text) {
      // For text generation models
      assistantText = result.generated_text;
    } else if (result && result.choices && result.choices[0]) {
      // For chat-like models
      assistantText = result.choices[0].message?.content ||
                     result.choices[0].text ||
                     JSON.stringify(result);
    } else {
      // Fallback to stringifying the entire result
      assistantText = typeof result === 'string' ? result : JSON.stringify(result);
    }

    // Save assistant message to DB
    await prisma.message.create({
      data: {
        role: "assistant",
        content: assistantText,
        userId: user!.id,
        conversationId: convId!,
      },
    });

    // Create a stream to send the response back
    const encoder = new TextEncoder();

    const stream = new ReadableStream({
      start(controller) {
        // Send the complete response
        controller.enqueue(encoder.encode(assistantText));
        controller.close();
      }
    });

    return new Response(stream, {
      headers: {
        "Content-Type": "text/plain; charset=utf-8",
        "Cache-Control": "no-cache",
      },
    });
  } catch (err) {
    console.error("SEND ROUTE ERROR:", err);
    return NextResponse.json({ error: "Server error" }, { status: 500 });
  }
}
```